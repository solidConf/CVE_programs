//
// Created by zy on 23-6-4.
//
int read( int loc , int len )
{
    int count = 0;
    if( flag == 1 ) //whether EOF or not
        return 0;
    while( loc < len )
    {
        int num =  __VERIFIER_nondet_int();
        if( num == 0 ) //abnormal
        {
            return -1;
        }
        else
        {
            if( num < 0 )
                num =  -num;
            num = num % 1000;
            count++;
            if( num < 995 ) //read a char
            {
                loc++;
                continue;
            }
            else // EOF
            {
                flag = 1;
                return count;
            }
        }
    }
    return count;
}
int seek(int file, long offset, int whence) {
    // 根据 whence 参数计算新的文件指针位置
    long pos;
    switch (whence) {
        case SEEK_SET: // 文件开头
            pos = offset;
            break;
        case SEEK_CUR: // 当前位置
            pos = ftell(file) + offset;
            break;
        case SEEK_END: // 文件末尾
            pos = fseek(file, 0, SEEK_END) + offset;
            break;
        default: // 错误的 whence 参数
            errno = EINVAL; // 错误码：invalid argument
            return -1;
    }

    // 检查文件指针的位置是否越界
    if (pos < 0) {
        errno = EINVAL; // 错误码：invalid argument
        return -1;
    }

    // 移动文件指针到新位置
    if (fseek(file, pos, SEEK_SET) != 0) {
        errno = EINVAL; // 错误码：invalid argument
        return -1;
    }

    return 0;
}
int main(){
    char* subBox_type = __VERIFIER_nondet_string();
    int subBox_length = __VERIFIER_nondet_int();
    while (read(subBox_type, sizeof(subBox)) == sizeof(subBox) && subBox_length )
    {
        if (subBox_length > io_size) {
            return 1;
        }

        seek(restore,BasicIo::beg);
        seek(subBox_length, Exiv2::BasicIo::cur);
        if (seek(subBox_length, Exiv2::BasicIo::cur) != 0 ) {
            throw Error(kerCorruptedMetadata);
        }
        restore = io_->tell();
    }

}