/*
Commit Number: 3c6779c37482d8c322446629a5407d7bd912b23d
URL: https://github.com/private-octopus/picoquic/issues/969
Project Name: picoquic
termination: FALSE
*/
#include <stdlib.h>
#define PICOQUIC_IN_RANGE(v, min, max)                  (((v) & ~((min)^(max))) == (min))
#define  uint8_t unsigned char
#define  size_t unsigned long
#define  uint64_t unsigned long
//#define NULL 0
#define uint16_t unsigned short
_Bool __VERIFIER_nondet_bool();

typedef enum {
    picoquic_frame_type_padding = 0,
    picoquic_frame_type_ping = 1,
    picoquic_frame_type_ack = 0x02,
    picoquic_frame_type_ack_ecn = 0x03,
    picoquic_frame_type_reset_stream = 0x04,
    picoquic_frame_type_stop_sending = 0x05,
    picoquic_frame_type_crypto_hs = 0x06,
    picoquic_frame_type_new_token = 0x07,
    picoquic_frame_type_stream_range_min = 0x08,
    picoquic_frame_type_stream_range_max = 0x0f,
    picoquic_frame_type_max_data = 0x10,
    picoquic_frame_type_max_stream_data = 0x11,
    picoquic_frame_type_max_streams_bidir = 0x12,
    picoquic_frame_type_max_streams_unidir = 0x13,
    picoquic_frame_type_data_blocked = 0x14,
    picoquic_frame_type_stream_data_blocked = 0x15,
    picoquic_frame_type_streams_blocked_bidir = 0x16,
    picoquic_frame_type_streams_blocked_unidir = 0x17,
    picoquic_frame_type_new_connection_id = 0x18,
    picoquic_frame_type_retire_connection_id = 0x19,
    picoquic_frame_type_path_challenge = 0x1a,
    picoquic_frame_type_path_response = 0x1b,
    picoquic_frame_type_connection_close = 0x1c,
    picoquic_frame_type_application_close = 0x1d,
    picoquic_frame_type_handshake_done = 0x1e,
    picoquic_frame_type_datagram = 0x30,
    picoquic_frame_type_datagram_l = 0x31,
    picoquic_frame_type_ack_frequency = 0xAF,
    picoquic_frame_type_time_stamp = 757
} picoquic_frame_type_enum_t;

/******************************************/
size_t picoquic_varint_decode(const uint8_t* bytes, size_t max_bytes, uint64_t* n64)
{
    size_t length = ((size_t)1) << ((bytes[0] & 0xC0) >> 6);

    if (length > max_bytes) {
        length = 0;
        *n64 = 0;
    } else {
        uint64_t v = *bytes++ & 0x3F;

        for (size_t i = 1; i < length; i++) {
            v <<= 8;
            v += *bytes++;
        }

        *n64 = v;
    }

    return length;
}

//int picoquic_parse_stream_header(const uint8_t* bytes, size_t bytes_max,
//                                 uint64_t* stream_id, uint64_t* offset, size_t* data_length, int* fin,
//                                 size_t* consumed)
//{
//    int ret = 0;
//    int len = bytes[0] & 2;
//    int off = bytes[0] & 4;
//    uint64_t length = 0;
//    size_t l_stream = 0;
//    size_t l_len = 0;
//    size_t l_off = 0;
//    size_t byte_index = 1;
//
//    *fin = bytes[0] & 1;
//
//    if (bytes_max > byte_index) {
//        l_stream = picoquic_varint_decode(bytes + byte_index, bytes_max - byte_index, stream_id);
//        byte_index += l_stream;
//    }
//
//    if (off == 0) {
//        *offset = 0;
//    } else if (bytes_max > byte_index) {
//        l_off = picoquic_varint_decode(bytes + byte_index, bytes_max - byte_index, offset);
//        byte_index += l_off;
//    }
//
//    if (bytes_max < byte_index || l_stream == 0 || (off != 0 && l_off == 0)) {
//        DBG_PRINTF("stream frame header too large: first_byte=0x%02x, bytes_max=%" PRIst,
//                bytes[0], bytes_max);
//        *data_length = 0;
//        byte_index = bytes_max;
//        ret = -1;
//    } else if (len == 0) {
//        *data_length = bytes_max - byte_index;
//    } else {
//        if (bytes_max > byte_index) {
//            l_len = picoquic_varint_decode(bytes + byte_index, bytes_max - byte_index, &length);
//            byte_index += l_len;
//            *data_length = (size_t)length;
//        }
//
//        if (l_len == 0 || bytes_max < byte_index) {
//            DBG_PRINTF("stream frame header too large: first_byte=0x%02x, bytes_max=%" PRIst,
//                    bytes[0], bytes_max);
//            byte_index = bytes_max;
//            ret = -1;
//        } else if (byte_index + length > bytes_max) {
//            DBG_PRINTF("stream data past the end of the packet: first_byte=0x%02x, data_length=%" PRIst ", max_bytes=%" PRIst,
//                    bytes[0], *data_length, bytes_max);
//            ret = -1;
//        }
//    }
//
//    *consumed = byte_index;
//    return ret;
//}

uint8_t* picoquic_decode_stream_frame(uint8_t* bytes, const uint8_t* bytes_max)
{
    uint64_t stream_id;
    size_t   data_length;
    uint64_t offset;
    int      fin;
    size_t   consumed;
    offset = 4611686018427387903l;
    if (__VERIFIER_nondet_bool()) {
        bytes = NULL;
    }else if (offset + data_length >= (1ull<<62)){
       // doing nothing
    } else if (__VERIFIER_nondet_bool()) {
        bytes = NULL;
    } else {
        bytes += data_length;
    }

    return bytes;
}


static uint8_t* picoquic_skip_0len_frame(uint8_t* bytes, const uint8_t* bytes_max)
{
    uint8_t frame = bytes[0];
    do {
        bytes++;
    } while (bytes < bytes_max && *bytes == frame);
    return bytes;
}

typedef enum {
    picoquic_epoch_initial = 0,
    picoquic_epoch_0rtt = 1,
    picoquic_epoch_handshake = 2,
    picoquic_epoch_1rtt = 3
} picoquic_epoch_enum;


int main(){

    size_t bytes_maxsize = 21;
    uint8_t* bytes =(uint8_t*)malloc(sizeof(uint8_t)*(bytes_maxsize + 1));
    picoquic_epoch_enum epoch = __VERIFIER_nondet_uchar();
    uint8_t* bytes_max  = bytes + bytes_maxsize;
    for (int i = 0; i < bytes_maxsize + 1; ++i) {
        bytes[i] = i;
    }
    while (bytes != NULL && bytes < bytes_max) {
        uint8_t first_byte = bytes[0];
        if (PICOQUIC_IN_RANGE(first_byte, picoquic_frame_type_stream_range_min, picoquic_frame_type_stream_range_max)) {
            if (epoch != 1 && epoch != 3) {
                bytes = NULL;
                break;
            }
            bytes = picoquic_decode_stream_frame(bytes, bytes_max);
        }
        else if (first_byte == picoquic_frame_type_ack) {
            if (epoch == picoquic_epoch_0rtt) {
                bytes = NULL;
                break;
            }
            bytes = bytes + 1;
        }
        else if (first_byte == picoquic_frame_type_ack_ecn) {
            if (epoch == picoquic_epoch_0rtt) {
                bytes = NULL;
                break;
            }
            bytes = bytes + 1;
        }
        else if (epoch != picoquic_epoch_0rtt && epoch != picoquic_epoch_1rtt && first_byte != picoquic_frame_type_padding
                 && first_byte != picoquic_frame_type_ping
                 && first_byte != picoquic_frame_type_connection_close
                 && first_byte != picoquic_frame_type_crypto_hs) {

        }
        else {
            switch (first_byte) {
                return 1;
                }
            }
        }
    }